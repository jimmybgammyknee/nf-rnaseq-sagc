def printVersion(String version) {
    println(
        """
        ==============================================================
                  SAGC RNA-SEQ NEXTFLOW PIPELINE ${version}           
        ==============================================================
        """.stripIndent()
    )
}

def printHelpMessage() {
    println(
        """
        A pipeline for RNA-seq quantification via alignment methods.
            * STAR: Splice aware alignment
            * Umi-tools/Sambamba: BAM deduplication
            * Subread FeatureCounts: Quantification

        Nextflow Arguments:
            -profile <str>                          Which Nextflow profile to use: SHOULD always be 'conda,slurm'

        Arguments: These are mandatory for SAGC datasets
            --library_type <str>                    String indicating 'paired' or 'single' end data (valid: 'paired', 'single')
            --index <str>                           Type of indexing (valid: 'single', 'dual', 'umi')
            --path_bcl <str>                        Directory path to BCL file for sequencing run of interest
            --genome <str>                          Which genome release to use. (Valid: HG38, GRCH37)
            --outdir <str>                          Directory path to output directory. Will be created if it doesn't exist already
            --email <str>                           Your SAHMRI email
            --partition <str>                       SAHMRI HPC partition to use (valid: 'sahmri_prod_hpc', 'sahmri_cancer_hpc')
            --node_list <str>                       SAHMRI HPC nodes to use (valid: sahmri_prod_hpc=edp-prd-lin-hpc0{1,6}, sahmri_cancer_hpc=edp-prd-lin-hpc0{7,8})

        Optional Arguments (user provided FastQ data):
            --library_ext <str>                     Regular expression string to match sequence files (E.g. '/path/to/files/*_R{1,2}.fastq.gz')
            --samplesheet <str>                     Path to custom sample sheet in Illumina format (if data is from BCL) or two column CSV; path and file base-name
            --umi_ext <str>                         Regular expression string to match UMI files (E.g. '/path/to/files/*_I1.fastq.gz')

        Optional Software Arguments (general):
            --fastp_optional_args <str>             Quoted string of optional arguments to pass to FastP
            --umitools_optional_args <str>          Quoted string of optional arguments to pass to Umi-tools
            --star_optional_args <str>              Quoted string of optional arguments to pass to STAR aligner
            --featurecounts_optional_args <str>     Quoted string of optional arguments to pass to FeatureCounts

        The 'Optional Arguments' should only be provided if the sequence data hasn't been generated by the SAGC.
        If the data is custom (i.e. not being created from the BCL files), the '--library_ext' argument is used
        to pattern match all FastQ files at the specified location. Which files to match are obtained from the
        second column in the custom sample sheet. If the custom data has UMIs, then they can be captured too by
        providing the '--umi_ext' argument.

        Example custom sample sheet (csv):

            path,basename
            /path/to/reads,sampleA
            /path/to/reads,sampleB
            /path/to/reads,sampleC
        """.stripIndent()
    )
}

def callHelp(Map args, String version) {

    if(args.help == true) {
        printVersion(version)
        printHelpMessage()
        System.exit(0)
    }

}

def checkAndSetArgs(Map args) {

    // Temporary Map object
    def ret = [:] // Return object (can be edited)
    ret.putAll(args)

    // Predefined variables
    def hpc_partition = [ 'sahmri_prod_hpc', 'sahmri_cancer_hpc' ]
    def hpc_nodelist_prod = ['edp-prd-lin-hpc01', 'edp-prd-lin-hpc02',
                             'edp-prd-lin-hpc03','edp-prd-lin-hpc04',
                             'edp-prd-lin-hpc05', 'edp-prd-lin-hpc06']
    def hpc_nodelist_cancer = ['edp-prd-lin-hpc07', 'edp-prd-lin-hpc08']

    // ################################################################################
    // Required arguments - RNA-seq pipeline
    try {
        assert args.library_type
        assert args.genome
        assert args.index
        assert args.outdir
        assert args.email
    } catch (AssertionError e) {
        println("""ERROR: Ensure the following arguments are not 'false':
            --library_type
            --genome
            --index
            --outdir
            --email\n""".stripIndent())

        println(e.getMessage())
        System.exit(1)
    }

    // User has passed samplesheet
    if (args.samplesheet) {

        // Check user provided file path exists
        File ss = new File(args.samplesheet)
        try {
            assert ss.exists()
        } catch (AssertionError e) {
            println("ERROR: Path '$args.samplesheet' to '--samplesheet' does not exist")
            println(e.getMessage())
            System.exit(1)
        }

        // User has passed path_bcl - custom illumina samplesheet
        if (args.path_bcl) {
            assert file(args.path_bcl).isDirectory() : "ERROR: Directory '${args.path_bcl}' provided to '--path_bcl' does not exist"

            // Check if there is a sample project in the Illumina sample sheet
            ret.sampleProject = checkSampleProject(args.samplesheet)
            analysis_type = 'sagc'

        // User has not passed path_bcl - custom dataset - must have extension to regex files
        } else {
            assert args.library_ext : "ERROR: Argument '--library_ext' has not been provided"
            analysis_type = 'custom'
        }

    // Samplesheet has not been passed - Only way this can progress is if 'path_bcl' has been passed
    } else {
        assert args.path_bcl : """ERROR: Both '--samplesheet' and '--path_bcl' are empty. See below:
            * Provide --samplesheet AND --library_ext if using a non-SAGC dataset
            * Provide --samplesheet (Illumina format) AND --path_bcl for an SAGC sequencing run
            * Provide --path_bcl for a SAGC sequencing runs using the default Illumina samplesheet within the directory""".stripIndent()
        assert file(args.path_bcl).isDirectory() : "ERROR: Directory '${args.path_bcl}' provided to '--path_bcl' does not exist"
        assert file(args.path_bcl + '/SampleSheet.csv') : "ERROR: No default samplesheet exists in ${args.path_bcl}"

        // Check if there is a sample project in the Illumina sample sheet
        ret.sampleProject = checkSampleProject(args.path_bcl + '/SampleSheet.csv')
        ret.samplesheet = file(args.path_bcl + '/SampleSheet.csv')
        analysis_type = 'sagc'
    }

    // ################################################################################
    // Genome check
    if(!args.genomes.containsKey(args.genome)) {
        println("ERROR: Provided genome " + args.genome + " is not a supported genome version")
        System.exit(1)
    }

    // ################################################################################
    // Index check
    try {
        assert args.index == 'single' || 
               args.index == 'dual' || 
               args.index == 'umi'
    } catch (AssertionError e) {
        println("ERROR: Argument to '--index' ($args.index) must be one of 'single', 'dual' or 'umi'")
        println(e.getMessage())
        System.exit(1)
    }

    // ################################################################################
    // Valid combination of library type and index value
    if(args.library_type == 'single') {
        try {
            assert args.index != 'umi'
            assert args.index != 'dual'
        } catch (AssertionError e) {
            println("ERROR: Library type ($args.library_type) and index type ($args.index) are incompatible")
            println(e.getMessage())
            System.exit(1)
        }
    }

    // ################################################################################
    // Check Umi sequences
    if (args.index == 'umi') {

        // Custom data - 'umi_ext' must be provided
        if (analysis_type == 'custom') {
            assert args.umi_ext : "ERROR: Argument '--umi_ext' has not been provided"
        }

        // SAGC data - files built from BCL - 'umi_ext' must NOT be provided
        if (analysis_type == 'sagc') {
            assert args.umi_ext == false : "ERROR: Argument provided to '--umi_ext' when data is being generated from BCL files. Should remain 'false'"
        }
    
    // NOT an UMI run - should not pass 'umi_ext'
    } else {
        assert args.umi_ext == false : "ERROR: Argument provided to '--umi_ext' when '--index' is NOT 'umi'"
    }

    // ################################################################################  
    // User profile - check that partitions are valid
    if( workflow.profile.tokenize(',').contains('slurm') ) {

        // Valid partition selection
        if(!hpc_partition.contains(args.partition)) {
            println("ERROR: Partition ${args.partition} is not valid. Please use either of the following - " + hpc_partition.join(' OR '))
            System.exit(1)
        }

        // Valid node selection
        if( args.partition == 'sahmri_prod_hpc' ) {
            if(!hpc_nodelist_prod.containsAll(args.node_list.tokenize(','))) {
                println("ERROR: Invalid node selection for partition ${args.partition}\n\tValid: " +
                hpc_nodelist_prod.join(', '))
                System.exit(1)
            }
        }

        if( args.partition == 'sahmri_cancer_hpc' ) {
            if((!hpc_nodelist_cancer.containsAll(args.node_list.tokenize(','))) ) {
                println("ERROR: Invalid node selection for partition ${args.partition}\n\tValid: " + hpc_nodelist_cancer.join(', '))
                System.exit(1)
            }
        }
    }
    
    // ################################################################################
    // Assign genome files to parameters
    ret.genome_fasta = file(args.genomes[args.genome].fasta)
    ret.genome_gtf = file(args.genomes[args.genome].gtf)
    ret.star_index = file(args.genomes[args.genome].starIdx)

    // Clean up return object
    ret = ret.findAll({!['genomes', 'help'].contains(it.key)})
    return ret
}

def printArguments(Map args) {

    required = [ 'library_type', 'library_ext', 'genome', 'samplesheet', 'path_bcl',
                 'index', 'umi_ext', 'sampleProject', 'outdir', 'email']
    subset_required = args.subMap(required)
    
    genomeRelated = [ 'genome_fasta', 'genome_gtf', 'star_index' ]
    subset_genomeRelated = args.subMap(genomeRelated)
    
    optionalArgs = [ 'umiadd_optional_args', 'featurecounts_optional_args', 
                     'fastp_optional_args', 'umitools_optional_args', 
                     'star_optional_args', 'fastqc_optional_args' ]
    subset_optionalArgs = args.subMap(optionalArgs)
    
    resources = args.findAll { k,v -> !(k in required + genomeRelated + optionalArgs) }.keySet()
    subset_resources = args.subMap(resources)

    lst = [ subset_required, subset_optionalArgs, subset_genomeRelated, subset_resources ]

    println(
        """
        ##################################################
        ################### Arguments ####################
        """.stripIndent())

    lst.each { l -> 
        l.each {key, value ->

            if(value instanceof java.util.ArrayList) {
                println("$key:")
                value.each { v -> 
                    println("  $v")
                }
            } else {
                println("$key: $value")
            }
        }
        println('')
    }
}

// Used to check if Sample_Project column is populated in Illumina samplesheet
def checkSampleProject(csvPath) {
    File csv = new File(csvPath)
    def lst = csv.readLines()

    // Indicies of [Data] section + SampleProject column
    headerIdx = lst.findIndexOf {x -> x =~ /\[Data\]/} + 1
    sampleProjectIdx = lst[headerIdx].tokenize(',').indexOf('Sample_Project')
    
    // false if column is missing OR column is empty - true if value is specified
    if (sampleProjectIdx != -1) {
        logical = ! lst[headerIdx + 1].split(',')[sampleProjectIdx].isEmpty()
    } else {
        logical = false
    }
    
    return logical
}

// Used to build filepath strings used by fromFilePairs()
def getSampleFromCSV( csvPath,  libExt, index,  umiExt, retObj) {
    
    File csv = new File(csvPath)
    def csv_lines = csv.readLines()
    csv_lines.remove(0) // Remove header row

    def reads_list = []
    def umi_list = []
    csv_lines.each { line ->
        line_list = line.tokenize(',')

        reads = line_list[0] + '/' + line_list[1] + '*' + libExt
        reads_list.add(reads)

        if(index == 'umi') {
            i1 = line_list[0] + '/' + line_list[1] + '*'  + umiExt
            umi_list.add(i1)
        }
    }

    // List to return based on argument
    if(retObj == 'umis') {
        return umi_list
    } else {
        return reads_list
    }
}
